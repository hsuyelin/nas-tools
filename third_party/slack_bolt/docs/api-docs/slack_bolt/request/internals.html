<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>slack_bolt.request.internals API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_bolt.request.internals</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
from typing import Optional, Dict, Union, Any, Sequence
from urllib.parse import parse_qsl, parse_qs

from slack_bolt.context import BoltContext


def parse_query(query: Optional[Union[str, Dict[str, str], Dict[str, Sequence[str]]]]) -&gt; Dict[str, Sequence[str]]:
    if query is None:
        return {}
    elif isinstance(query, str):
        return parse_qs(query, keep_blank_values=True)
    elif isinstance(query, dict) or hasattr(query, &#34;items&#34;):
        result: Dict[str, Sequence[str]] = {}
        for name, value in query.items():
            if isinstance(value, list):
                result[name] = value
            elif isinstance(value, str):
                result[name] = [value]
            else:
                raise ValueError(f&#34;Unsupported type ({type(value)}) of element in headers ({query})&#34;)
        return result  # type: ignore
    else:
        raise ValueError(f&#34;Unsupported type of query detected ({type(query)})&#34;)


def parse_body(body: str, content_type: Optional[str]) -&gt; Dict[str, Any]:
    if not body:
        return {}
    if (content_type is not None and content_type == &#34;application/json&#34;) or body.startswith(&#34;{&#34;):
        return json.loads(body)
    else:
        if &#34;payload&#34; in body:  # This is not JSON format yet
            params = dict(parse_qsl(body, keep_blank_values=True))
            if params.get(&#34;payload&#34;) is not None:
                return json.loads(params.get(&#34;payload&#34;))
            else:
                return {}
        else:
            return dict(parse_qsl(body, keep_blank_values=True))


def extract_is_enterprise_install(payload: Dict[str, Any]) -&gt; Optional[bool]:
    if payload.get(&#34;authorizations&#34;) is not None and len(payload[&#34;authorizations&#34;]) &gt; 0:
        # To make Events API handling functioning also for shared channels,
        # we should use .authorizations[0].is_enterprise_install over .is_enterprise_install
        return extract_is_enterprise_install(payload[&#34;authorizations&#34;][0])
    if &#34;is_enterprise_install&#34; in payload:
        is_enterprise_install = payload.get(&#34;is_enterprise_install&#34;)
        return is_enterprise_install is not None and (is_enterprise_install is True or is_enterprise_install == &#34;true&#34;)
    return False


def extract_enterprise_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    org = payload.get(&#34;enterprise&#34;)
    if org is not None:
        if isinstance(org, str):
            return org
        elif &#34;id&#34; in org:
            return org.get(&#34;id&#34;)
    if payload.get(&#34;authorizations&#34;) is not None and len(payload[&#34;authorizations&#34;]) &gt; 0:
        # To make Events API handling functioning also for shared channels,
        # we should use .authorizations[0].enterprise_id over .enterprise_id
        return extract_enterprise_id(payload[&#34;authorizations&#34;][0])
    if &#34;enterprise_id&#34; in payload:
        return payload.get(&#34;enterprise_id&#34;)
    if payload.get(&#34;team&#34;) is not None and &#34;enterprise_id&#34; in payload[&#34;team&#34;]:
        # In the case where the type is view_submission
        return payload[&#34;team&#34;].get(&#34;enterprise_id&#34;)
    if payload.get(&#34;event&#34;) is not None:
        return extract_enterprise_id(payload[&#34;event&#34;])
    return None


def extract_actor_enterprise_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    if payload.get(&#34;is_ext_shared_channel&#34;) is True:
        if payload.get(&#34;type&#34;) == &#34;event_callback&#34;:
            # For safety, we don&#39;t set actor IDs for the events like &#34;file_shared&#34;,
            # which do not provide any team ID in $.event data. In the case, the IDs cannot be correct.
            event_team_id = payload.get(&#34;event&#34;, {}).get(&#34;user_team&#34;) or payload.get(&#34;event&#34;, {}).get(&#34;team&#34;)
            if event_team_id is not None and str(event_team_id).startswith(&#34;E&#34;):
                return event_team_id
            if event_team_id == payload.get(&#34;team_id&#34;):
                return payload.get(&#34;enterprise_id&#34;)
            return None
    return extract_enterprise_id(payload)


def extract_team_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    if payload.get(&#34;view&#34;, {}).get(&#34;app_installed_team_id&#34;) is not None:
        # view_submission payloads can have `view.app_installed_team_id` when a modal view that was opened
        # in a different workspace via some operations inside a Slack Connect channel.
        # Note that the same for enterprise_id does not exist. When you need to know the enterprise_id as well,
        # you have to run some query toward your InstallationStore to know the org where the team_id belongs to.
        return payload.get(&#34;view&#34;)[&#34;app_installed_team_id&#34;]
    if payload.get(&#34;team&#34;) is not None:
        # With org-wide installations, payload.team in interactivity payloads can be None
        # You need to extract either payload.user.team_id or payload.view.team_id as below
        team = payload.get(&#34;team&#34;)
        if isinstance(team, str):
            return team
        elif team and &#34;id&#34; in team:
            return team.get(&#34;id&#34;)
    if payload.get(&#34;authorizations&#34;) is not None and len(payload[&#34;authorizations&#34;]) &gt; 0:
        # To make Events API handling functioning also for shared channels,
        # we should use .authorizations[0].team_id over .team_id
        return extract_team_id(payload[&#34;authorizations&#34;][0])
    if &#34;team_id&#34; in payload:
        return payload.get(&#34;team_id&#34;)
    if payload.get(&#34;event&#34;) is not None:
        return extract_team_id(payload[&#34;event&#34;])
    if payload.get(&#34;user&#34;) is not None:
        return payload.get(&#34;user&#34;)[&#34;team_id&#34;]
    if payload.get(&#34;view&#34;) is not None:
        return payload.get(&#34;view&#34;)[&#34;team_id&#34;]
    return None


def extract_actor_team_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    if payload.get(&#34;is_ext_shared_channel&#34;) is True:
        if payload.get(&#34;type&#34;) == &#34;event_callback&#34;:
            event_type = payload.get(&#34;event&#34;, {}).get(&#34;type&#34;)
            if event_type == &#34;app_mention&#34;:
                # The $.event.user_team can be an enterprise_id in app_mention events.
                # In the scenario, there is no way to retrieve actor_team_id as of March 2023
                user_team = payload.get(&#34;event&#34;, {}).get(&#34;user_team&#34;)
                if user_team is None:
                    # working with an app installed in this user&#39;s org/workspace side
                    return payload.get(&#34;event&#34;, {}).get(&#34;team&#34;)
                if str(user_team).startswith(&#34;T&#34;):
                    # interacting from a connected non-grid workspace
                    return user_team
                # Interacting from a connected grid workspace; in this case, team_id cannot be resolved as of March 2023
                return None
            # For safety, we don&#39;t set actor IDs for the events like &#34;file_shared&#34;,
            # which do not provide any team ID in $.event data. In the case, the IDs cannot be correct.
            event_user_team = payload.get(&#34;event&#34;, {}).get(&#34;user_team&#34;)
            if event_user_team is not None:
                if str(event_user_team).startswith(&#34;T&#34;):
                    return event_user_team
                elif str(event_user_team).startswith(&#34;E&#34;):
                    if event_user_team == payload.get(&#34;enterprise_id&#34;):
                        return payload.get(&#34;team_id&#34;)
                    elif event_user_team == payload.get(&#34;context_enterprise_id&#34;):
                        return payload.get(&#34;context_team_id&#34;)

            event_team = payload.get(&#34;event&#34;, {}).get(&#34;team&#34;)
            if event_team is not None:
                if str(event_team).startswith(&#34;T&#34;):
                    return event_team
                elif str(event_team).startswith(&#34;E&#34;):
                    if event_team == payload.get(&#34;enterprise_id&#34;):
                        return payload.get(&#34;team_id&#34;)
                    elif event_team == payload.get(&#34;context_enterprise_id&#34;):
                        return payload.get(&#34;context_team_id&#34;)
            return None

    return extract_team_id(payload)


def extract_user_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    user = payload.get(&#34;user&#34;)
    if user is not None:
        if isinstance(user, str):
            return user
        elif &#34;id&#34; in user:
            return user.get(&#34;id&#34;)
    if &#34;user_id&#34; in payload:
        return payload.get(&#34;user_id&#34;)
    if payload.get(&#34;event&#34;) is not None:
        return extract_user_id(payload[&#34;event&#34;])
    if payload.get(&#34;message&#34;) is not None:
        # message_changed: body[&#34;event&#34;][&#34;message&#34;]
        return extract_user_id(payload[&#34;message&#34;])
    if payload.get(&#34;previous_message&#34;) is not None:
        # message_deleted: body[&#34;event&#34;][&#34;previous_message&#34;]
        return extract_user_id(payload[&#34;previous_message&#34;])
    return None


def extract_actor_user_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    if payload.get(&#34;is_ext_shared_channel&#34;) is True:
        if payload.get(&#34;type&#34;) == &#34;event_callback&#34;:
            event = payload.get(&#34;event&#34;)
            if event is None:
                return None
            if extract_actor_enterprise_id(payload) is None and extract_actor_team_id(payload) is None:
                # When both enterprise_id and team_id are not identified, we skip returning user_id too for safety
                return None
            return event.get(&#34;user&#34;) or event.get(&#34;user_id&#34;)
    return extract_user_id(payload)


def extract_channel_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    channel = payload.get(&#34;channel&#34;)
    if channel is not None:
        if isinstance(channel, str):
            return channel
        elif &#34;id&#34; in channel:
            return channel.get(&#34;id&#34;)
    if &#34;channel_id&#34; in payload:
        return payload.get(&#34;channel_id&#34;)
    if payload.get(&#34;event&#34;) is not None:
        return extract_channel_id(payload[&#34;event&#34;])
    if payload.get(&#34;item&#34;) is not None:
        # reaction_added: body[&#34;event&#34;][&#34;item&#34;]
        return extract_channel_id(payload[&#34;item&#34;])
    return None


def build_context(context: BoltContext, body: Dict[str, Any]) -&gt; BoltContext:
    context[&#34;is_enterprise_install&#34;] = extract_is_enterprise_install(body)
    enterprise_id = extract_enterprise_id(body)
    if enterprise_id:
        context[&#34;enterprise_id&#34;] = enterprise_id
    team_id = extract_team_id(body)
    if team_id:
        context[&#34;team_id&#34;] = team_id
    user_id = extract_user_id(body)
    if user_id:
        context[&#34;user_id&#34;] = user_id
    # Actor IDs are useful for Events API on a Slack Connect channel
    actor_enterprise_id = extract_actor_enterprise_id(body)
    if actor_enterprise_id:
        context[&#34;actor_enterprise_id&#34;] = actor_enterprise_id
    actor_team_id = extract_actor_team_id(body)
    if actor_team_id:
        context[&#34;actor_team_id&#34;] = actor_team_id
    actor_user_id = extract_actor_user_id(body)
    if actor_user_id:
        context[&#34;actor_user_id&#34;] = actor_user_id
    channel_id = extract_channel_id(body)
    if channel_id:
        context[&#34;channel_id&#34;] = channel_id
    if &#34;response_url&#34; in body:
        context[&#34;response_url&#34;] = body[&#34;response_url&#34;]
    elif &#34;response_urls&#34; in body:
        # In the case where response_url_enabled: true in a modal exists
        response_urls = body[&#34;response_urls&#34;]
        if len(response_urls) &gt;= 1:
            if len(response_urls) &gt; 1:
                context.logger.debug(debug_multiple_response_urls_detected())
            response_url = response_urls[0].get(&#34;response_url&#34;)
            context[&#34;response_url&#34;] = response_url
    return context


def extract_content_type(headers: Dict[str, Sequence[str]]) -&gt; Optional[str]:
    content_type: Optional[str] = headers.get(&#34;content-type&#34;, [None])[0]
    if content_type:
        return content_type.split(&#34;;&#34;)[0]
    return None


def build_normalized_headers(headers: Optional[Dict[str, Union[str, Sequence[str]]]]) -&gt; Dict[str, Sequence[str]]:
    normalized_headers: Dict[str, Sequence[str]] = {}
    if headers is not None:
        for key, value in headers.items():
            normalized_name = key.lower()
            if isinstance(value, list):
                normalized_headers[normalized_name] = value
            elif isinstance(value, str):
                normalized_headers[normalized_name] = [value]
            else:
                raise ValueError(f&#34;Unsupported type ({type(value)}) of element in headers ({headers})&#34;)
    return normalized_headers  # type: ignore


def error_message_raw_body_required_in_http_mode() -&gt; str:
    return &#34;`body` must be a raw string data when running in the HTTP server mode&#34;


def debug_multiple_response_urls_detected() -&gt; str:
    return (
        &#34;`response_urls` in the body has multiple URLs in it. &#34;
        &#34;If you would like to use non-primary one, &#34;
        &#34;please manually extract the one from body[&#39;response_urls&#39;].&#34;
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="slack_bolt.request.internals.build_context"><code class="name flex">
<span>def <span class="ident">build_context</span></span>(<span>context: <a title="slack_bolt.context.context.BoltContext" href="../context/context.html#slack_bolt.context.context.BoltContext">BoltContext</a>, body: Dict[str, Any]) ‑> <a title="slack_bolt.context.context.BoltContext" href="../context/context.html#slack_bolt.context.context.BoltContext">BoltContext</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_context(context: BoltContext, body: Dict[str, Any]) -&gt; BoltContext:
    context[&#34;is_enterprise_install&#34;] = extract_is_enterprise_install(body)
    enterprise_id = extract_enterprise_id(body)
    if enterprise_id:
        context[&#34;enterprise_id&#34;] = enterprise_id
    team_id = extract_team_id(body)
    if team_id:
        context[&#34;team_id&#34;] = team_id
    user_id = extract_user_id(body)
    if user_id:
        context[&#34;user_id&#34;] = user_id
    # Actor IDs are useful for Events API on a Slack Connect channel
    actor_enterprise_id = extract_actor_enterprise_id(body)
    if actor_enterprise_id:
        context[&#34;actor_enterprise_id&#34;] = actor_enterprise_id
    actor_team_id = extract_actor_team_id(body)
    if actor_team_id:
        context[&#34;actor_team_id&#34;] = actor_team_id
    actor_user_id = extract_actor_user_id(body)
    if actor_user_id:
        context[&#34;actor_user_id&#34;] = actor_user_id
    channel_id = extract_channel_id(body)
    if channel_id:
        context[&#34;channel_id&#34;] = channel_id
    if &#34;response_url&#34; in body:
        context[&#34;response_url&#34;] = body[&#34;response_url&#34;]
    elif &#34;response_urls&#34; in body:
        # In the case where response_url_enabled: true in a modal exists
        response_urls = body[&#34;response_urls&#34;]
        if len(response_urls) &gt;= 1:
            if len(response_urls) &gt; 1:
                context.logger.debug(debug_multiple_response_urls_detected())
            response_url = response_urls[0].get(&#34;response_url&#34;)
            context[&#34;response_url&#34;] = response_url
    return context</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.build_normalized_headers"><code class="name flex">
<span>def <span class="ident">build_normalized_headers</span></span>(<span>headers: Optional[Dict[str, Union[str, Sequence[str]]]]) ‑> Dict[str, Sequence[str]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_normalized_headers(headers: Optional[Dict[str, Union[str, Sequence[str]]]]) -&gt; Dict[str, Sequence[str]]:
    normalized_headers: Dict[str, Sequence[str]] = {}
    if headers is not None:
        for key, value in headers.items():
            normalized_name = key.lower()
            if isinstance(value, list):
                normalized_headers[normalized_name] = value
            elif isinstance(value, str):
                normalized_headers[normalized_name] = [value]
            else:
                raise ValueError(f&#34;Unsupported type ({type(value)}) of element in headers ({headers})&#34;)
    return normalized_headers  # type: ignore</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.debug_multiple_response_urls_detected"><code class="name flex">
<span>def <span class="ident">debug_multiple_response_urls_detected</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_multiple_response_urls_detected() -&gt; str:
    return (
        &#34;`response_urls` in the body has multiple URLs in it. &#34;
        &#34;If you would like to use non-primary one, &#34;
        &#34;please manually extract the one from body[&#39;response_urls&#39;].&#34;
    )</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.error_message_raw_body_required_in_http_mode"><code class="name flex">
<span>def <span class="ident">error_message_raw_body_required_in_http_mode</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_message_raw_body_required_in_http_mode() -&gt; str:
    return &#34;`body` must be a raw string data when running in the HTTP server mode&#34;</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.extract_actor_enterprise_id"><code class="name flex">
<span>def <span class="ident">extract_actor_enterprise_id</span></span>(<span>payload: Dict[str, Any]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_actor_enterprise_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    if payload.get(&#34;is_ext_shared_channel&#34;) is True:
        if payload.get(&#34;type&#34;) == &#34;event_callback&#34;:
            # For safety, we don&#39;t set actor IDs for the events like &#34;file_shared&#34;,
            # which do not provide any team ID in $.event data. In the case, the IDs cannot be correct.
            event_team_id = payload.get(&#34;event&#34;, {}).get(&#34;user_team&#34;) or payload.get(&#34;event&#34;, {}).get(&#34;team&#34;)
            if event_team_id is not None and str(event_team_id).startswith(&#34;E&#34;):
                return event_team_id
            if event_team_id == payload.get(&#34;team_id&#34;):
                return payload.get(&#34;enterprise_id&#34;)
            return None
    return extract_enterprise_id(payload)</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.extract_actor_team_id"><code class="name flex">
<span>def <span class="ident">extract_actor_team_id</span></span>(<span>payload: Dict[str, Any]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_actor_team_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    if payload.get(&#34;is_ext_shared_channel&#34;) is True:
        if payload.get(&#34;type&#34;) == &#34;event_callback&#34;:
            event_type = payload.get(&#34;event&#34;, {}).get(&#34;type&#34;)
            if event_type == &#34;app_mention&#34;:
                # The $.event.user_team can be an enterprise_id in app_mention events.
                # In the scenario, there is no way to retrieve actor_team_id as of March 2023
                user_team = payload.get(&#34;event&#34;, {}).get(&#34;user_team&#34;)
                if user_team is None:
                    # working with an app installed in this user&#39;s org/workspace side
                    return payload.get(&#34;event&#34;, {}).get(&#34;team&#34;)
                if str(user_team).startswith(&#34;T&#34;):
                    # interacting from a connected non-grid workspace
                    return user_team
                # Interacting from a connected grid workspace; in this case, team_id cannot be resolved as of March 2023
                return None
            # For safety, we don&#39;t set actor IDs for the events like &#34;file_shared&#34;,
            # which do not provide any team ID in $.event data. In the case, the IDs cannot be correct.
            event_user_team = payload.get(&#34;event&#34;, {}).get(&#34;user_team&#34;)
            if event_user_team is not None:
                if str(event_user_team).startswith(&#34;T&#34;):
                    return event_user_team
                elif str(event_user_team).startswith(&#34;E&#34;):
                    if event_user_team == payload.get(&#34;enterprise_id&#34;):
                        return payload.get(&#34;team_id&#34;)
                    elif event_user_team == payload.get(&#34;context_enterprise_id&#34;):
                        return payload.get(&#34;context_team_id&#34;)

            event_team = payload.get(&#34;event&#34;, {}).get(&#34;team&#34;)
            if event_team is not None:
                if str(event_team).startswith(&#34;T&#34;):
                    return event_team
                elif str(event_team).startswith(&#34;E&#34;):
                    if event_team == payload.get(&#34;enterprise_id&#34;):
                        return payload.get(&#34;team_id&#34;)
                    elif event_team == payload.get(&#34;context_enterprise_id&#34;):
                        return payload.get(&#34;context_team_id&#34;)
            return None

    return extract_team_id(payload)</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.extract_actor_user_id"><code class="name flex">
<span>def <span class="ident">extract_actor_user_id</span></span>(<span>payload: Dict[str, Any]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_actor_user_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    if payload.get(&#34;is_ext_shared_channel&#34;) is True:
        if payload.get(&#34;type&#34;) == &#34;event_callback&#34;:
            event = payload.get(&#34;event&#34;)
            if event is None:
                return None
            if extract_actor_enterprise_id(payload) is None and extract_actor_team_id(payload) is None:
                # When both enterprise_id and team_id are not identified, we skip returning user_id too for safety
                return None
            return event.get(&#34;user&#34;) or event.get(&#34;user_id&#34;)
    return extract_user_id(payload)</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.extract_channel_id"><code class="name flex">
<span>def <span class="ident">extract_channel_id</span></span>(<span>payload: Dict[str, Any]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_channel_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    channel = payload.get(&#34;channel&#34;)
    if channel is not None:
        if isinstance(channel, str):
            return channel
        elif &#34;id&#34; in channel:
            return channel.get(&#34;id&#34;)
    if &#34;channel_id&#34; in payload:
        return payload.get(&#34;channel_id&#34;)
    if payload.get(&#34;event&#34;) is not None:
        return extract_channel_id(payload[&#34;event&#34;])
    if payload.get(&#34;item&#34;) is not None:
        # reaction_added: body[&#34;event&#34;][&#34;item&#34;]
        return extract_channel_id(payload[&#34;item&#34;])
    return None</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.extract_content_type"><code class="name flex">
<span>def <span class="ident">extract_content_type</span></span>(<span>headers: Dict[str, Sequence[str]]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_content_type(headers: Dict[str, Sequence[str]]) -&gt; Optional[str]:
    content_type: Optional[str] = headers.get(&#34;content-type&#34;, [None])[0]
    if content_type:
        return content_type.split(&#34;;&#34;)[0]
    return None</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.extract_enterprise_id"><code class="name flex">
<span>def <span class="ident">extract_enterprise_id</span></span>(<span>payload: Dict[str, Any]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_enterprise_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    org = payload.get(&#34;enterprise&#34;)
    if org is not None:
        if isinstance(org, str):
            return org
        elif &#34;id&#34; in org:
            return org.get(&#34;id&#34;)
    if payload.get(&#34;authorizations&#34;) is not None and len(payload[&#34;authorizations&#34;]) &gt; 0:
        # To make Events API handling functioning also for shared channels,
        # we should use .authorizations[0].enterprise_id over .enterprise_id
        return extract_enterprise_id(payload[&#34;authorizations&#34;][0])
    if &#34;enterprise_id&#34; in payload:
        return payload.get(&#34;enterprise_id&#34;)
    if payload.get(&#34;team&#34;) is not None and &#34;enterprise_id&#34; in payload[&#34;team&#34;]:
        # In the case where the type is view_submission
        return payload[&#34;team&#34;].get(&#34;enterprise_id&#34;)
    if payload.get(&#34;event&#34;) is not None:
        return extract_enterprise_id(payload[&#34;event&#34;])
    return None</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.extract_is_enterprise_install"><code class="name flex">
<span>def <span class="ident">extract_is_enterprise_install</span></span>(<span>payload: Dict[str, Any]) ‑> Optional[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_is_enterprise_install(payload: Dict[str, Any]) -&gt; Optional[bool]:
    if payload.get(&#34;authorizations&#34;) is not None and len(payload[&#34;authorizations&#34;]) &gt; 0:
        # To make Events API handling functioning also for shared channels,
        # we should use .authorizations[0].is_enterprise_install over .is_enterprise_install
        return extract_is_enterprise_install(payload[&#34;authorizations&#34;][0])
    if &#34;is_enterprise_install&#34; in payload:
        is_enterprise_install = payload.get(&#34;is_enterprise_install&#34;)
        return is_enterprise_install is not None and (is_enterprise_install is True or is_enterprise_install == &#34;true&#34;)
    return False</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.extract_team_id"><code class="name flex">
<span>def <span class="ident">extract_team_id</span></span>(<span>payload: Dict[str, Any]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_team_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    if payload.get(&#34;view&#34;, {}).get(&#34;app_installed_team_id&#34;) is not None:
        # view_submission payloads can have `view.app_installed_team_id` when a modal view that was opened
        # in a different workspace via some operations inside a Slack Connect channel.
        # Note that the same for enterprise_id does not exist. When you need to know the enterprise_id as well,
        # you have to run some query toward your InstallationStore to know the org where the team_id belongs to.
        return payload.get(&#34;view&#34;)[&#34;app_installed_team_id&#34;]
    if payload.get(&#34;team&#34;) is not None:
        # With org-wide installations, payload.team in interactivity payloads can be None
        # You need to extract either payload.user.team_id or payload.view.team_id as below
        team = payload.get(&#34;team&#34;)
        if isinstance(team, str):
            return team
        elif team and &#34;id&#34; in team:
            return team.get(&#34;id&#34;)
    if payload.get(&#34;authorizations&#34;) is not None and len(payload[&#34;authorizations&#34;]) &gt; 0:
        # To make Events API handling functioning also for shared channels,
        # we should use .authorizations[0].team_id over .team_id
        return extract_team_id(payload[&#34;authorizations&#34;][0])
    if &#34;team_id&#34; in payload:
        return payload.get(&#34;team_id&#34;)
    if payload.get(&#34;event&#34;) is not None:
        return extract_team_id(payload[&#34;event&#34;])
    if payload.get(&#34;user&#34;) is not None:
        return payload.get(&#34;user&#34;)[&#34;team_id&#34;]
    if payload.get(&#34;view&#34;) is not None:
        return payload.get(&#34;view&#34;)[&#34;team_id&#34;]
    return None</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.extract_user_id"><code class="name flex">
<span>def <span class="ident">extract_user_id</span></span>(<span>payload: Dict[str, Any]) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_user_id(payload: Dict[str, Any]) -&gt; Optional[str]:
    user = payload.get(&#34;user&#34;)
    if user is not None:
        if isinstance(user, str):
            return user
        elif &#34;id&#34; in user:
            return user.get(&#34;id&#34;)
    if &#34;user_id&#34; in payload:
        return payload.get(&#34;user_id&#34;)
    if payload.get(&#34;event&#34;) is not None:
        return extract_user_id(payload[&#34;event&#34;])
    if payload.get(&#34;message&#34;) is not None:
        # message_changed: body[&#34;event&#34;][&#34;message&#34;]
        return extract_user_id(payload[&#34;message&#34;])
    if payload.get(&#34;previous_message&#34;) is not None:
        # message_deleted: body[&#34;event&#34;][&#34;previous_message&#34;]
        return extract_user_id(payload[&#34;previous_message&#34;])
    return None</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.parse_body"><code class="name flex">
<span>def <span class="ident">parse_body</span></span>(<span>body: str, content_type: Optional[str]) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_body(body: str, content_type: Optional[str]) -&gt; Dict[str, Any]:
    if not body:
        return {}
    if (content_type is not None and content_type == &#34;application/json&#34;) or body.startswith(&#34;{&#34;):
        return json.loads(body)
    else:
        if &#34;payload&#34; in body:  # This is not JSON format yet
            params = dict(parse_qsl(body, keep_blank_values=True))
            if params.get(&#34;payload&#34;) is not None:
                return json.loads(params.get(&#34;payload&#34;))
            else:
                return {}
        else:
            return dict(parse_qsl(body, keep_blank_values=True))</code></pre>
</details>
</dd>
<dt id="slack_bolt.request.internals.parse_query"><code class="name flex">
<span>def <span class="ident">parse_query</span></span>(<span>query: Union[str, Dict[str, str], Dict[str, Sequence[str]], ForwardRef(None)]) ‑> Dict[str, Sequence[str]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_query(query: Optional[Union[str, Dict[str, str], Dict[str, Sequence[str]]]]) -&gt; Dict[str, Sequence[str]]:
    if query is None:
        return {}
    elif isinstance(query, str):
        return parse_qs(query, keep_blank_values=True)
    elif isinstance(query, dict) or hasattr(query, &#34;items&#34;):
        result: Dict[str, Sequence[str]] = {}
        for name, value in query.items():
            if isinstance(value, list):
                result[name] = value
            elif isinstance(value, str):
                result[name] = [value]
            else:
                raise ValueError(f&#34;Unsupported type ({type(value)}) of element in headers ({query})&#34;)
        return result  # type: ignore
    else:
        raise ValueError(f&#34;Unsupported type of query detected ({type(query)})&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_bolt.request" href="index.html">slack_bolt.request</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="slack_bolt.request.internals.build_context" href="#slack_bolt.request.internals.build_context">build_context</a></code></li>
<li><code><a title="slack_bolt.request.internals.build_normalized_headers" href="#slack_bolt.request.internals.build_normalized_headers">build_normalized_headers</a></code></li>
<li><code><a title="slack_bolt.request.internals.debug_multiple_response_urls_detected" href="#slack_bolt.request.internals.debug_multiple_response_urls_detected">debug_multiple_response_urls_detected</a></code></li>
<li><code><a title="slack_bolt.request.internals.error_message_raw_body_required_in_http_mode" href="#slack_bolt.request.internals.error_message_raw_body_required_in_http_mode">error_message_raw_body_required_in_http_mode</a></code></li>
<li><code><a title="slack_bolt.request.internals.extract_actor_enterprise_id" href="#slack_bolt.request.internals.extract_actor_enterprise_id">extract_actor_enterprise_id</a></code></li>
<li><code><a title="slack_bolt.request.internals.extract_actor_team_id" href="#slack_bolt.request.internals.extract_actor_team_id">extract_actor_team_id</a></code></li>
<li><code><a title="slack_bolt.request.internals.extract_actor_user_id" href="#slack_bolt.request.internals.extract_actor_user_id">extract_actor_user_id</a></code></li>
<li><code><a title="slack_bolt.request.internals.extract_channel_id" href="#slack_bolt.request.internals.extract_channel_id">extract_channel_id</a></code></li>
<li><code><a title="slack_bolt.request.internals.extract_content_type" href="#slack_bolt.request.internals.extract_content_type">extract_content_type</a></code></li>
<li><code><a title="slack_bolt.request.internals.extract_enterprise_id" href="#slack_bolt.request.internals.extract_enterprise_id">extract_enterprise_id</a></code></li>
<li><code><a title="slack_bolt.request.internals.extract_is_enterprise_install" href="#slack_bolt.request.internals.extract_is_enterprise_install">extract_is_enterprise_install</a></code></li>
<li><code><a title="slack_bolt.request.internals.extract_team_id" href="#slack_bolt.request.internals.extract_team_id">extract_team_id</a></code></li>
<li><code><a title="slack_bolt.request.internals.extract_user_id" href="#slack_bolt.request.internals.extract_user_id">extract_user_id</a></code></li>
<li><code><a title="slack_bolt.request.internals.parse_body" href="#slack_bolt.request.internals.parse_body">parse_body</a></code></li>
<li><code><a title="slack_bolt.request.internals.parse_query" href="#slack_bolt.request.internals.parse_query">parse_query</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>